package main

import (
	"context"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"
	"time"
)

// ClaudeHookEvent represents the JSON data received from Claude Code hooks
type ClaudeHookEvent struct {
	SessionID      string `json:"session_id"`
	TranscriptPath string `json:"transcript_path"`
	CWD            string `json:"cwd"`
	HookEventName  string `json:"hook_event_name"`
	ToolName       string `json:"tool_name,omitempty"`
	Timestamp      string `json:"timestamp"`
	Message        string `json:"message,omitempty"`
}

// ClaudeHookResponse represents the response sent back to Claude Code
type ClaudeHookResponse struct {
	Continue *bool  `json:"continue,omitempty"`
	Decision string `json:"decision,omitempty"`
}

// Config holds application configuration
type Config struct {
	LogFile      string
	PollInterval time.Duration
	Verbose      bool
}

// Logger provides structured logging with levels
type Logger struct {
	verbose bool
}

func newLogger(verbose bool) *Logger {
	return &Logger{verbose: verbose}
}

func (l *Logger) Info(msg string, args ...any) {
	log.Printf("[INFO] "+msg, args...)
}

func (l *Logger) Error(msg string, args ...any) {
	log.Printf("[ERROR] "+msg, args...)
}

func (l *Logger) Debug(msg string, args ...any) {
	if l.verbose {
		log.Printf("[DEBUG] "+msg, args...)
	}
}

// validateHookEvent validates the required fields of a hook event
func validateHookEvent(event *ClaudeHookEvent) error {
	if event == nil {
		return errors.New("hook event is nil")
	}
	if strings.TrimSpace(event.SessionID) == "" {
		return errors.New("session_id is required")
	}
	if strings.TrimSpace(event.HookEventName) == "" {
		return errors.New("hook_event_name is required")
	}
	return nil
}

// ensureLogDirectory creates the log directory if it doesn't exist
func ensureLogDirectory(logFile string) error {
	dir := filepath.Dir(logFile)
	if dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create log directory: %w", err)
		}
	}
	return nil
}

func showHelp() {
	fmt.Printf("Usage: %s [options]\n\n", os.Args[0])
	fmt.Println("Description:")
	fmt.Println("  A tool for logging and monitoring Claude Code hook events")
	fmt.Println()
	fmt.Println("Options:")
	flag.PrintDefaults()
	fmt.Println()
	fmt.Println("Examples:")
	fmt.Println("  claudetogo --help                    Show this help")
	fmt.Println("  claudetogo --setup                   Run interactive setup wizard (recommended for first use)")
	fmt.Println("  claudetogo --hook                    Process hook event from stdin (logs and allows all events)")
	fmt.Println("  claudetogo --config myconfig.json    Use custom configuration file")
	fmt.Println("  claudetogo --monitor                 Monitor events in real-time")
	fmt.Println("  claudetogo --monitor --verbose       Monitor with debug output")
	fmt.Println("  claudetogo --logfile custom.log      Use custom log file")
	fmt.Println()
	fmt.Println("Getting Started:")
	fmt.Println("  For first-time users, run 'claudetogo --setup' to configure the application")
}

// saveHookEvent safely saves a hook event to the log file
func saveHookEvent(event ClaudeHookEvent, config Config, logger *Logger) error {
	if err := validateHookEvent(&event); err != nil {
		return fmt.Errorf("invalid hook event: %w", err)
	}

	if err := ensureLogDirectory(config.LogFile); err != nil {
		return err
	}

	file, err := os.OpenFile(config.LogFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("failed to open log file: %w", err)
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	if err := encoder.Encode(event); err != nil {
		return fmt.Errorf("failed to encode event: %w", err)
	}

	logger.Debug("Saved event: %s (Session: %s)", event.HookEventName, event.SessionID)
	return nil
}

// formatEventOutput formats an event for display
func formatEventOutput(event ClaudeHookEvent) string {
	timestamp := time.Now().Format("15:04:05")
	sessionID := event.SessionID
	if len(sessionID) > 8 {
		sessionID = sessionID[:8]
	}

	toolInfo := ""
	if event.ToolName != "" {
		toolInfo = fmt.Sprintf(" | Tool: %s", event.ToolName)
	}

	return fmt.Sprintf("[%s] üéØ %s | Session: %s%s",
		timestamp, event.HookEventName, sessionID, toolInfo)
}

// monitorEvents monitors the log file for new events with graceful shutdown
func monitorEvents(ctx context.Context, config Config, logger *Logger) error {
	logger.Info("Starting event monitor (Poll interval: %v)", config.PollInterval)

	var lastSize int64 = 0
	if info, err := os.Stat(config.LogFile); err == nil {
		lastSize = info.Size()
		logger.Debug("Initial file size: %d bytes", lastSize)
	}

	ticker := time.NewTicker(config.PollInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			logger.Info("Monitor stopping...")
			return ctx.Err()
		case <-ticker.C:
			if err := checkForNewEvents(config.LogFile, &lastSize, logger); err != nil {
				logger.Error("Error checking for events: %v", err)
			}
		}
	}
}

// checkForNewEvents checks for and processes new events in the log file
func checkForNewEvents(logFile string, lastSize *int64, logger *Logger) error {
	info, err := os.Stat(logFile)
	if err != nil {
		if os.IsNotExist(err) {
			logger.Debug("Log file does not exist yet: %s", logFile)
			return nil
		}
		return fmt.Errorf("failed to stat log file: %w", err)
	}

	currentSize := info.Size()
	if currentSize <= *lastSize {
		return nil
	}

	logger.Debug("File size changed: %d -> %d", *lastSize, currentSize)

	file, err := os.Open(logFile)
	if err != nil {
		return fmt.Errorf("failed to open log file: %w", err)
	}
	defer file.Close()

	if _, err := file.Seek(*lastSize, 0); err != nil {
		return fmt.Errorf("failed to seek in log file: %w", err)
	}

	decoder := json.NewDecoder(file)
	for decoder.More() {
		var event ClaudeHookEvent
		if err := decoder.Decode(&event); err != nil {
			if err == io.EOF {
				break
			}
			logger.Error("Failed to decode event: %v", err)
			continue
		}

		fmt.Println(formatEventOutput(event))
	}

	*lastSize = currentSize
	return nil
}

// processHookFromStdin reads and processes a hook event from stdin
func processHookFromStdin(config Config, logger *Logger) error {
	var event ClaudeHookEvent
	decoder := json.NewDecoder(os.Stdin)
	if err := decoder.Decode(&event); err != nil {
		return fmt.Errorf("failed to decode hook event from stdin: %w", err)
	}

	if err := saveHookEvent(event, config, logger); err != nil {
		return fmt.Errorf("failed to save hook event: %w", err)
	}

	// Process the event and generate response
	response := processHookEvent(event, logger)

	// Send response back to Claude
	if err := sendHookResponse(response, logger); err != nil {
		return fmt.Errorf("failed to send hook response: %w", err)
	}

	logger.Info("Hook event processed successfully")
	return nil
}

// setupGracefulShutdown sets up graceful shutdown handling
func setupGracefulShutdown() (context.Context, context.CancelFunc) {
	ctx, cancel := context.WithCancel(context.Background())

	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)

	go func() {
		<-c
		log.Println("\nReceived shutdown signal, stopping gracefully...")
		cancel()
	}()

	return ctx, cancel
}

// processHookEvent processes a hook event and returns appropriate response
func processHookEvent(event ClaudeHookEvent, logger *Logger) ClaudeHookResponse {
	logger.Debug("Processing hook event: %s", event.HookEventName)

	// Always allow - this is stage 1: log everything
	continueVal := true
	return ClaudeHookResponse{
		Continue: &continueVal,
		Decision: "approve",
	}
}

// sendHookResponse sends the response back to Claude Code via stdout
func sendHookResponse(response ClaudeHookResponse, logger *Logger) error {
	encoder := json.NewEncoder(os.Stdout)
	if err := encoder.Encode(response); err != nil {
		return fmt.Errorf("failed to encode response: %w", err)
	}

	logger.Debug("Sent response: %s", response.Decision)
	return nil
}

// ConfigFile represents the configuration file structure
type ConfigFile struct {
	LogFile      string `json:"logFile"`
	PollInterval string `json:"pollInterval"`
	Verbose      bool   `json:"verbose"`
}

// runSetupWizard guides the user through interactive setup
func runSetupWizard() error {
	fmt.Println("üéØ Welcome to ClaudeToGo Setup Wizard!")
	fmt.Println("=====================================")
	fmt.Println()
	fmt.Println("This wizard will help you configure ClaudeToGo for monitoring")
	fmt.Println("Claude Code's tool usage through hooks.")
	fmt.Println()

	config := ConfigFile{
		LogFile:      "claude-events.log",
		PollInterval: "100ms",
		Verbose:      false,
	}

	fmt.Println("üìã Configuration Questions:")
	fmt.Println()
	fmt.Println("ClaudeToGo will log all Claude Code tool events for future analysis.")
	fmt.Println()

	// Ask about log file location
	fmt.Print("1. Where should events be logged? [claude-events.log]: ")
	var logFileInput string
	fmt.Scanln(&logFileInput)
	if logFileInput != "" {
		config.LogFile = logFileInput
	}
	fmt.Printf("‚úì Events will be logged to: %s\n", config.LogFile)
	fmt.Println()

	// Ask about verbose logging
	fmt.Print("2. Enable verbose debug logging? [y/N]: ")
	var verboseInput string
	fmt.Scanln(&verboseInput)
	config.Verbose = strings.ToLower(verboseInput) == "y" || strings.ToLower(verboseInput) == "yes"
	if config.Verbose {
		fmt.Println("‚úì Verbose logging enabled")
	} else {
		fmt.Println("‚úì Normal logging level")
	}
	fmt.Println()

	// Save configuration
	configPath := "claudetogo-config.json"
	if err := saveConfigFile(config, configPath); err != nil {
		return fmt.Errorf("failed to save configuration: %w", err)
	}
	fmt.Printf("‚úÖ Configuration saved to: %s\n", configPath)
	fmt.Println()

	// Ask about Claude Code settings.json configuration
	fmt.Print("3. Would you like to automatically configure Claude Code hooks? [y/N]: ")
	var configureHooksInput string
	fmt.Scanln(&configureHooksInput)
	if strings.ToLower(configureHooksInput) == "y" || strings.ToLower(configureHooksInput) == "yes" {
		if err := configureClaudeHooks(config); err != nil {
			fmt.Printf("‚ö†Ô∏è  Could not configure Claude Code hooks automatically: %v\n", err)
			fmt.Println("   You can configure them manually using the instructions below.")
		} else {
			fmt.Println("‚úÖ Claude Code hooks configured successfully!")
		}
	} else {
		fmt.Println("‚úì You can configure Claude Code hooks manually later")
	}
	fmt.Println()

	// Show usage examples
	showSetupResults(config)

	return nil
}

// saveConfigFile saves the configuration to a JSON file
func saveConfigFile(config ConfigFile, path string) error {
	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(config)
}

// loadConfigFile loads configuration from a JSON file
func loadConfigFile(path string) (*ConfigFile, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var config ConfigFile
	decoder := json.NewDecoder(file)
	if err := decoder.Decode(&config); err != nil {
		return nil, err
	}

	return &config, nil
}

// ClaudeSettingsConfig represents the Claude Code settings.json structure
type ClaudeSettingsConfig struct {
	Hooks map[string][]HookMatcher `json:"hooks,omitempty"`
	// Preserve all other unknown fields in the settings.json
	Extra map[string]json.RawMessage `json:"-"`
}

type HookMatcher struct {
	Matcher string       `json:"matcher"`
	Hooks   []HookConfig `json:"hooks"`
}

type HookConfig struct {
	Type    string `json:"type"`
	Command string `json:"command"`
	Timeout *int   `json:"timeout,omitempty"`
}

// ConfigLocation represents a configuration location choice
type ConfigLocation struct {
	Path        string
	Description string
	Scope       string // "global", "project", "local"
}

// configureClaudeHooks automatically configures Claude Code settings.json
func configureClaudeHooks(config ConfigFile) error {
	// Ask user to choose configuration location
	location, err := chooseConfigLocation()
	if err != nil {
		return fmt.Errorf("failed to choose configuration location: %w", err)
	}

	return configureClaudeHooksAtLocation(config, location)
}

// chooseConfigLocation lets user choose between global and project configuration
func chooseConfigLocation() (*ConfigLocation, error) {
	fmt.Println("\nüìÅ Choose Claude Code Configuration Location:")
	fmt.Println("============================================")

	// Detect current working directory
	cwd, err := os.Getwd()
	if err != nil {
		return nil, fmt.Errorf("could not get current directory: %w", err)
	}

	// Get home directory
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("could not get user home directory: %w", err)
	}

	locations := []ConfigLocation{
		{
			Path:        filepath.Join(homeDir, ".claude", "settings.json"),
			Description: "Global configuration (affects all projects)",
			Scope:       "global",
		},
		{
			Path:        filepath.Join(cwd, ".claude", "settings.json"),
			Description: "Project configuration (shared with team, committed to repo)",
			Scope:       "project",
		},
		{
			Path:        filepath.Join(cwd, ".claude", "settings.local.json"),
			Description: "Local project configuration (personal, not committed)",
			Scope:       "local",
		},
	}

	// Show options
	for i, loc := range locations {
		existsMarker := ""
		if _, err := os.Stat(loc.Path); err == nil {
			existsMarker = " ‚úÖ (exists)"
		}
		fmt.Printf("  [%d] %s%s\n", i+1, loc.Description, existsMarker)
		fmt.Printf("      Path: %s\n", loc.Path)
		fmt.Println()
	}

	fmt.Print("Choose location [1-3]: ")
	var choice string
	fmt.Scanln(&choice)

	switch choice {
	case "1":
		return &locations[0], nil
	case "2":
		return &locations[1], nil
	case "3":
		return &locations[2], nil
	default:
		fmt.Println("‚úì Defaulting to global configuration")
		return &locations[0], nil
	}
}

// loadExistingSettings safely loads existing settings.json while preserving unknown fields
func loadExistingSettings(path string) (*ClaudeSettingsConfig, error) {
	var settingsConfig ClaudeSettingsConfig

	if _, err := os.Stat(path); err != nil {
		// File doesn't exist, return empty config
		settingsConfig.Extra = make(map[string]json.RawMessage)
		return &settingsConfig, nil
	}

	// File exists, load it with full preservation
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("could not open existing settings.json: %w", err)
	}
	defer file.Close()

	// First, read into a generic map to capture all fields
	var rawConfig map[string]json.RawMessage
	decoder := json.NewDecoder(file)
	if err := decoder.Decode(&rawConfig); err != nil {
		return nil, fmt.Errorf("could not parse existing settings.json: %w", err)
	}

	// Initialize Extra map
	settingsConfig.Extra = make(map[string]json.RawMessage)

	// Extract known fields and preserve unknown ones
	for key, value := range rawConfig {
		switch key {
		case "hooks":
			if err := json.Unmarshal(value, &settingsConfig.Hooks); err != nil {
				return nil, fmt.Errorf("could not parse hooks field: %w", err)
			}
		default:
			// Preserve unknown fields
			settingsConfig.Extra[key] = value
		}
	}

	return &settingsConfig, nil
}

// saveSettingsWithPreservation safely saves settings while preserving unknown fields
func saveSettingsWithPreservation(settingsConfig *ClaudeSettingsConfig, path string) error {
	// Create a map to hold the final JSON structure
	finalConfig := make(map[string]any)

	// Add preserved unknown fields first
	for key, value := range settingsConfig.Extra {
		var unmarshaled any
		if err := json.Unmarshal(value, &unmarshaled); err != nil {
			return fmt.Errorf("could not unmarshal preserved field %s: %w", key, err)
		}
		finalConfig[key] = unmarshaled
	}

	// Add hooks configuration (this will override any existing hooks)
	if len(settingsConfig.Hooks) > 0 {
		finalConfig["hooks"] = settingsConfig.Hooks
	}

	// Create backup of existing file
	if _, err := os.Stat(path); err == nil {
		backupPath := path + ".backup"
		if err := copyFile(path, backupPath); err != nil {
			// Log warning but don't fail
			log.Printf("[WARNING] Could not create backup at %s: %v", backupPath, err)
		}
	}

	// Write the merged configuration
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("could not create settings.json: %w", err)
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(finalConfig); err != nil {
		return fmt.Errorf("could not write settings.json: %w", err)
	}

	return nil
}

// copyFile creates a backup copy of a file
func copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = io.Copy(dstFile, srcFile)
	return err
}

// isClaudeToGoHook identifies if a command is a ClaudeToGo hook
func isClaudeToGoHook(command string) bool {
	return strings.Contains(command, "claudetogo") && strings.Contains(command, "--hook")
}

// cleanupAllClaudeToGoHooks removes ClaudeToGo hooks from all hook types
// If a hook type contains only ClaudeToGo hooks, the entire type is removed
// If it contains mixed hooks, only ClaudeToGo hooks are filtered out
func cleanupAllClaudeToGoHooks(hooks map[string][]HookMatcher) {
	var keysToRemove []string

	for hookName, matchers := range hooks {
		var updatedMatchers []HookMatcher
		hasNonClaudeToGoHooks := false

		for _, matcher := range matchers {
			var preservedHooks []HookConfig

			for _, hook := range matcher.Hooks {
				if !isClaudeToGoHook(hook.Command) {
					preservedHooks = append(preservedHooks, hook)
					hasNonClaudeToGoHooks = true
				}
			}

			if len(preservedHooks) > 0 {
				updatedMatchers = append(updatedMatchers, HookMatcher{
					Matcher: matcher.Matcher,
					Hooks:   preservedHooks,
				})
			}
		}

		if hasNonClaudeToGoHooks {
			// Keep the hook type but with ClaudeToGo hooks filtered out
			hooks[hookName] = updatedMatchers
		} else {
			// Mark for removal if it contained only ClaudeToGo hooks
			keysToRemove = append(keysToRemove, hookName)
		}
	}

	// Remove hook types that contained only ClaudeToGo hooks
	for _, key := range keysToRemove {
		delete(hooks, key)
	}
}

// buildClaudeToGoCommand constructs the ClaudeToGo hook command string
func buildClaudeToGoCommand(config ConfigFile) string {
	var cmd strings.Builder

	execPath, err := os.Executable()
	if err != nil {
		execPath = "./claudetogo"
	}

	cmd.WriteString(execPath)
	cmd.WriteString(" --hook")

	if config.LogFile != "claude-events.log" {
		cmd.WriteString(fmt.Sprintf(" --logfile \"%s\"", config.LogFile))
	}

	if config.Verbose {
		cmd.WriteString(" --verbose")
	}

	return cmd.String()
}

// updateHookType adds our ClaudeToGo hook to existing matchers (ClaudeToGo hooks already cleaned up)
func updateHookType(existingMatchers []HookMatcher, newCommand string, timeout int) []HookMatcher {
	var updatedMatchers []HookMatcher
	hasWildcardMatcher := false

	// Preserve all existing matchers and add our hook to wildcard matcher if it exists
	for _, matcher := range existingMatchers {
		if matcher.Matcher == "*" {
			hasWildcardMatcher = true
			// Add our hook to existing wildcard matcher
			updatedHooks := append(matcher.Hooks, HookConfig{
				Type:    "command",
				Command: newCommand,
				Timeout: &timeout,
			})
			updatedMatchers = append(updatedMatchers, HookMatcher{
				Matcher: matcher.Matcher,
				Hooks:   updatedHooks,
			})
		} else {
			// Preserve non-wildcard matchers as-is
			updatedMatchers = append(updatedMatchers, matcher)
		}
	}

	// If no wildcard matcher exists, create one with our hook
	if !hasWildcardMatcher {
		updatedMatchers = append(updatedMatchers, HookMatcher{
			Matcher: "*",
			Hooks: []HookConfig{
				{
					Type:    "command",
					Command: newCommand,
					Timeout: &timeout,
				},
			},
		})
	}

	return updatedMatchers
}

// configureClaudeHooksAtLocation configures Claude Code hooks at specified location
func configureClaudeHooksAtLocation(config ConfigFile, location *ConfigLocation) error {
	// Ensure directory exists
	claudeDir := filepath.Dir(location.Path)
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		return fmt.Errorf("could not create directory %s: %w", claudeDir, err)
	}

	// Build the command from config
	newCommand := buildClaudeToGoCommand(config)
	timeout := 30

	// Load existing settings.json safely while preserving unknown fields
	settingsConfig, err := loadExistingSettings(location.Path)
	if err != nil {
		return fmt.Errorf("could not load existing settings: %w", err)
	}

	// Initialize hooks if nil
	if settingsConfig.Hooks == nil {
		settingsConfig.Hooks = make(map[string][]HookMatcher)
	}

	// Clean up all ClaudeToGo hooks from all hook types before adding new ones
	cleanupAllClaudeToGoHooks(settingsConfig.Hooks)

	// Add our new ClaudeToGo hooks to target hook types
	targetHooks := []string{"Stop", "Notification"}
	for _, hookType := range targetHooks {
		settingsConfig.Hooks[hookType] = updateHookType(settingsConfig.Hooks[hookType], newCommand, timeout)
	}

	// Save the updated settings.json while preserving existing configuration
	if err := saveSettingsWithPreservation(settingsConfig, location.Path); err != nil {
		return fmt.Errorf("could not save settings.json: %w", err)
	}

	fmt.Printf("‚úÖ Claude Code hooks configured at: %s\n", location.Path)
	fmt.Printf("üìã Configuration scope: %s\n", location.Scope)

	return nil
}

// applyConfigFile applies configuration file settings, with command line flags taking precedence
func applyConfigFile(configFile *ConfigFile, config *Config) error {
	// Parse poll interval from string
	if configFile.PollInterval != "" {
		duration, err := time.ParseDuration(configFile.PollInterval)
		if err != nil {
			return fmt.Errorf("invalid poll interval in config file: %w", err)
		}
		config.PollInterval = duration
	}

	// Apply other settings (command line flags will override these later)
	config.LogFile = configFile.LogFile
	config.Verbose = configFile.Verbose

	return nil
}

// showSetupResults displays the setup results and usage instructions
func showSetupResults(config ConfigFile) {
	fmt.Println("üöÄ Setup Complete! Here's how to use ClaudeToGo:")
	fmt.Println("================================================")
	fmt.Println()
	fmt.Println("ClaudeToGo is now configured to log all Claude Code tool events.")
	fmt.Println("This is Stage 1: Event collection for future analysis.")
	fmt.Println()

	// Show the command to run based on configuration
	var cmd strings.Builder
	cmd.WriteString("./claudetogo --hook")

	if config.LogFile != "claude-events.log" {
		cmd.WriteString(fmt.Sprintf(" --logfile \"%s\"", config.LogFile))
	}

	if config.Verbose {
		cmd.WriteString(" --verbose")
	}

	fmt.Println("üìù To use as a Claude Code hook:")
	fmt.Printf("   %s\n", cmd.String())
	fmt.Println()

	fmt.Println("üìä To monitor events in real-time:")
	monitorCmd := "./claudetogo --monitor"
	if config.Verbose {
		monitorCmd += " --verbose"
	}
	if config.LogFile != "claude-events.log" {
		monitorCmd += fmt.Sprintf(" --logfile \"%s\"", config.LogFile)
	}
	fmt.Printf("   %s\n", monitorCmd)
	fmt.Println()

	fmt.Println("‚öôÔ∏è To configure Claude Code hooks manually:")
	fmt.Println("   1. Choose configuration location:")
	fmt.Println("      - Global: ~/.claude/settings.json")
	fmt.Println("      - Project: .claude/settings.json")
	fmt.Println("      - Local: .claude/settings.local.json")
	fmt.Println("   2. Add this hook configuration:")
	fmt.Println("   {")
	fmt.Println("     \"hooks\": {")
	fmt.Println("       \"Stop\": [")
	fmt.Println("         {")
	fmt.Println("           \"matcher\": \"*\",")
	fmt.Println("           \"hooks\": [")
	fmt.Println("             {")
	fmt.Println("               \"type\": \"command\",")
	fmt.Printf("               \"command\": \"%s\",\n", cmd.String())
	fmt.Println("               \"timeout\": 30")
	fmt.Println("             }")
	fmt.Println("           ]")
	fmt.Println("         }")
	fmt.Println("       ],")
	fmt.Println("       \"Notification\": [")
	fmt.Println("         {")
	fmt.Println("           \"matcher\": \"*\",")
	fmt.Println("           \"hooks\": [")
	fmt.Println("             {")
	fmt.Println("               \"type\": \"command\",")
	fmt.Printf("               \"command\": \"%s\",\n", cmd.String())
	fmt.Println("               \"timeout\": 30")
	fmt.Println("             }")
	fmt.Println("           ]")
	fmt.Println("         }")
	fmt.Println("       ]")
	fmt.Println("     }")
	fmt.Println("   }")
	fmt.Println()

	fmt.Println("üí° Tips:")
	fmt.Println("   - All tool events are logged and allowed (Stage 1: Event collection)")
	fmt.Println("   - Run with --help to see all available options")
	fmt.Println("   - Edit claudetogo-config.json to modify settings")
	fmt.Println("   - Use --setup again to reconfigure")
}

func main() {
	// Command line flags
	helpFlag := flag.Bool("help", false, "Show help information")
	setupFlag := flag.Bool("setup", false, "Run interactive setup wizard to configure the application")
	configFlag := flag.String("config", "", "Path to configuration file (JSON format)")
	hookFlag := flag.Bool("hook", false, "Process hook event from stdin (for Claude Code hooks)")
	monitorFlag := flag.Bool("monitor", false, "Monitor events in real-time")
	logFileFlag := flag.String("logfile", "claude-events.log", "Path to log file")
	verboseFlag := flag.Bool("verbose", false, "Enable verbose debug output")
	pollIntervalFlag := flag.Duration("poll-interval", 100*time.Millisecond, "Polling interval for monitoring")

	flag.Parse()

	// Show help and exit
	if *helpFlag {
		showHelp()
		return
	}

	// Run setup wizard
	if *setupFlag {
		if err := runSetupWizard(); err != nil {
			log.Printf("[ERROR] Setup failed: %v", err)
			os.Exit(1)
		}
		return
	}

	// Initialize configuration with defaults
	config := Config{
		LogFile:      "claude-events.log",
		PollInterval: 100 * time.Millisecond,
		Verbose:      false,
	}

	// Load configuration file if specified or default exists
	var configPath string
	if *configFlag != "" {
		configPath = *configFlag
	} else {
		// Check for default config file
		if _, err := os.Stat("claudetogo-config.json"); err == nil {
			configPath = "claudetogo-config.json"
		}
	}

	if configPath != "" {
		configFile, err := loadConfigFile(configPath)
		if err != nil {
			log.Printf("[ERROR] Failed to load config file '%s': %v", configPath, err)
			os.Exit(1)
		}

		if err := applyConfigFile(configFile, &config); err != nil {
			log.Printf("[ERROR] Failed to apply config file: %v", err)
			os.Exit(1)
		}

		log.Printf("[INFO] Loaded configuration from: %s", configPath)
	}

	// Command line flags override config file settings
	if flag.Lookup("logfile").Value.String() != flag.Lookup("logfile").DefValue {
		config.LogFile = *logFileFlag
	}
	if flag.Lookup("poll-interval").Value.String() != flag.Lookup("poll-interval").DefValue {
		config.PollInterval = *pollIntervalFlag
	}
	if *verboseFlag {
		config.Verbose = true
	}

	// Initialize logger
	logger := newLogger(config.Verbose)

	// Set up graceful shutdown
	ctx, cancel := setupGracefulShutdown()
	defer cancel()

	// Handle different modes
	if *monitorFlag {
		logger.Info("Monitoring Claude events... (Press Ctrl+C to stop)")
		if err := monitorEvents(ctx, config, logger); err != nil && err != context.Canceled {
			logger.Error("Monitor error: %v", err)
			os.Exit(1)
		}
		return
	}

	if *hookFlag {
		if err := processHookFromStdin(config, logger); err != nil {
			logger.Error("Hook processing error: %v", err)
			os.Exit(1)
		}
		return
	}

	// No flags specified, show help
	showHelp()
}
